Terminals unused in grammar

   IN
   ERROR


Grammar

    0 $accept: program $end

    1 @1: %empty

    2 program: PROGRAM ID @1 opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body '.'

    3 opt-type-sect: TYPE decl-list
    4              | %empty

    5 decl-list: decl ';' decl-list
    6          | decl ';'

    7 decl: id-list ':' domain

    8 @2: %empty

    9 id-list: ID @2 ',' id-list
   10        | ID

   11 domain: atomic-domain
   12       | array-domain
   13       | ID

   14 atomic-domain: INTEGER
   15              | STRING
   16              | BOOLEAN

   17 @3: %empty

   18 array-domain: ARRAY '[' INTCONST @3 ']' OF domain

   19 opt-var-sect: VAR decl-list
   20             | %empty

   21 opt-const-sect: CONST const-list-decl
   22               | %empty

   23 const-list-decl: const-decl const-list-decl
   24                | const-decl

   25 const-decl: decl ASSIGN const ';'

   26 const: INTCONST
   27      | STRCONST
   28      | BOOLCONST
   29      | array-const

   30 array-const: '[' const-list ']'

   31 const-list: const ',' const-list
   32           | const

   33 opt-module-list: module-list
   34                | %empty

   35 module-list: module-decl module-list
   36            | module-decl

   37 module-decl: procedure-decl
   38            | function-decl

   39 @4: %empty

   40 procedure-decl: PROC ID @4 '(' opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body ';'

   41 @5: %empty

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' ':' domain opt-type-sect opt-const-sect opt-module-list expr-body ';'

   43 opt-formal-list: formal-list
   44                | %empty

   45 formal-list: formal-decl ',' formal-list
   46            | formal-decl

   47 formal-decl: mode decl

   48 mode: %empty
   49     | OUT
   50     | INOUT

   51 @6: %empty

   52 @7: %empty

   53 stat-body: T_BEGIN ID @6 stat-list END ID @7

   54 @8: %empty

   55 @9: %empty

   56 expr-body: T_BEGIN ID @8 expr END ID @9

   57 stat-list: stat ';' stat-list
   58          | stat ';'

   59 stat: assign-stat
   60     | if-stat
   61     | while-stat
   62     | repeat-stat
   63     | for-stat
   64     | input-stat
   65     | output-stat
   66     | module-call
   67     | BREAK
   68     | EXIT

   69 input-stat: INPUT ID

   70 output-stat: OUTPUT expr

   71 @10: %empty

   72 for-stat: FOR ID @10 ASSIGN expr TO expr DO stat-list END

   73 while-stat: WHILE expr DO stat-list END

   74 repeat-stat: REPEAT stat-list UNTIL expr

   75 if-stat: IF expr THEN stat-list opt-elsif-stat-list opt-else-stat END

   76 opt-elsif-stat-list: ELSIF expr THEN stat-list opt-elsif-stat-list
   77                    | %empty

   78 opt-else-stat: ELSE stat-list
   79              | %empty

   80 assign-stat: left-hand-side ASSIGN expr

   81 left-hand-side: ID
   82               | indexing

   83 indexing: left-hand-side '[' expr ']'

   84 expr: expr bool-op bool-term
   85     | bool-term

   86 bool-op: AND
   87        | OR

   88 bool-term: comp-term comp-op comp-term
   89          | comp-term

   90 comp-op: EQUAL
   91        | NE
   92        | GT
   93        | GE
   94        | KT
   95        | KE

   96 comp-term: comp-term add-op term
   97          | term

   98 add-op: PLUS
   99       | MINUS

  100 term: term mul-op factor
  101     | factor

  102 mul-op: MUL
  103       | DIV

  104 factor: unary-op factor
  105       | '(' expr ')'
  106       | left-hand-side
  107       | const
  108       | cond-expr
  109       | module-call

  110 unary-op: MINUS
  111         | NOT

  112 cond-expr: IF expr THEN expr opt-elsif-expr-list ELSE expr END

  113 opt-elsif-expr-list: ELSIF expr THEN expr opt-elsif-expr-list
  114                    | %empty

  115 @11: %empty

  116 module-call: ID @11 '(' opt-expr-list ')'

  117 opt-expr-list: expr-list
  118              | %empty

  119 expr-list: expr ',' expr-list
  120          | expr


Terminals, with rules where they appear

$end (0) 0
'(' (40) 40 42 105 116
')' (41) 40 42 105 116
',' (44) 9 31 45 119
'.' (46) 2
':' (58) 7 42
';' (59) 5 6 25 40 42 57 58
'[' (91) 18 30 83
']' (93) 18 30 83
error (256)
ASSIGN (258) 25 72 80
EQUAL (259) 90
NE (260) 91
GT (261) 92
GE (262) 93
KT (263) 94
KE (264) 95
PLUS (265) 98
MINUS (266) 99 110
MUL (267) 102
DIV (268) 103
PROGRAM (269) 2
TYPE (270) 3
VAR (271) 19
CONST (272) 21
PROC (273) 40
FUNC (274) 42
IN (275)
OUT (276) 49
INOUT (277) 50
T_BEGIN (278) 53 56
END (279) 53 56 72 73 75 112
BREAK (280) 67
EXIT (281) 68
IF (282) 75 112
THEN (283) 75 76 112 113
ELSE (284) 78 112
ELSIF (285) 76 113
WHILE (286) 73
DO (287) 72 73
REPEAT (288) 74
UNTIL (289) 74
FOR (290) 72
TO (291) 72
INPUT (292) 69
OUTPUT (293) 70
AND (294) 86
OR (295) 87
NOT (296) 111
INTEGER (297) 14
STRING (298) 15
BOOLEAN (299) 16
INTCONST (300) 18 26
BOOLCONST (301) 28
STRCONST (302) 27
ID (303) 2 9 10 13 40 42 53 56 69 72 81 116
ERROR (304)
ARRAY (305) 18
OF (306) 18


Nonterminals, with rules where they appear

$accept (60)
    on left: 0
program (61)
    on left: 2, on right: 0
@1 (62)
    on left: 1, on right: 2
opt-type-sect (63)
    on left: 3 4, on right: 2 40 42
decl-list (64)
    on left: 5 6, on right: 3 5 19
decl (65)
    on left: 7, on right: 5 6 25 47
id-list (66)
    on left: 9 10, on right: 7 9
@2 (67)
    on left: 8, on right: 9
domain (68)
    on left: 11 12 13, on right: 7 18 42
atomic-domain (69)
    on left: 14 15 16, on right: 11
array-domain (70)
    on left: 18, on right: 12
@3 (71)
    on left: 17, on right: 18
opt-var-sect (72)
    on left: 19 20, on right: 2 40
opt-const-sect (73)
    on left: 21 22, on right: 2 40 42
const-list-decl (74)
    on left: 23 24, on right: 21 23
const-decl (75)
    on left: 25, on right: 23 24
const (76)
    on left: 26 27 28 29, on right: 25 31 32 107
array-const (77)
    on left: 30, on right: 29
const-list (78)
    on left: 31 32, on right: 30 31
opt-module-list (79)
    on left: 33 34, on right: 2 40 42
module-list (80)
    on left: 35 36, on right: 33 35
module-decl (81)
    on left: 37 38, on right: 35 36
procedure-decl (82)
    on left: 40, on right: 37
@4 (83)
    on left: 39, on right: 40
function-decl (84)
    on left: 42, on right: 38
@5 (85)
    on left: 41, on right: 42
opt-formal-list (86)
    on left: 43 44, on right: 40 42
formal-list (87)
    on left: 45 46, on right: 43 45
formal-decl (88)
    on left: 47, on right: 45 46
mode (89)
    on left: 48 49 50, on right: 47
stat-body (90)
    on left: 53, on right: 2 40
@6 (91)
    on left: 51, on right: 53
@7 (92)
    on left: 52, on right: 53
expr-body (93)
    on left: 56, on right: 42
@8 (94)
    on left: 54, on right: 56
@9 (95)
    on left: 55, on right: 56
stat-list (96)
    on left: 57 58, on right: 53 57 72 73 74 75 76 78
stat (97)
    on left: 59 60 61 62 63 64 65 66 67 68, on right: 57 58
input-stat (98)
    on left: 69, on right: 64
output-stat (99)
    on left: 70, on right: 65
for-stat (100)
    on left: 72, on right: 63
@10 (101)
    on left: 71, on right: 72
while-stat (102)
    on left: 73, on right: 61
repeat-stat (103)
    on left: 74, on right: 62
if-stat (104)
    on left: 75, on right: 60
opt-elsif-stat-list (105)
    on left: 76 77, on right: 75 76
opt-else-stat (106)
    on left: 78 79, on right: 75
assign-stat (107)
    on left: 80, on right: 59
left-hand-side (108)
    on left: 81 82, on right: 80 83 106
indexing (109)
    on left: 83, on right: 82
expr (110)
    on left: 84 85, on right: 56 70 72 73 74 75 76 80 83 84 105 112
    113 119 120
bool-op (111)
    on left: 86 87, on right: 84
bool-term (112)
    on left: 88 89, on right: 84 85
comp-op (113)
    on left: 90 91 92 93 94 95, on right: 88
comp-term (114)
    on left: 96 97, on right: 88 89 96
add-op (115)
    on left: 98 99, on right: 96
term (116)
    on left: 100 101, on right: 96 97 100
mul-op (117)
    on left: 102 103, on right: 100
factor (118)
    on left: 104 105 106 107 108 109, on right: 100 101 104
unary-op (119)
    on left: 110 111, on right: 104
cond-expr (120)
    on left: 112, on right: 108
opt-elsif-expr-list (121)
    on left: 113 114, on right: 112 113
module-call (122)
    on left: 116, on right: 66 109
@11 (123)
    on left: 115, on right: 116
opt-expr-list (124)
    on left: 117 118, on right: 116
expr-list (125)
    on left: 119 120, on right: 117 119


State 0

    0 $accept: . program $end

    PROGRAM  shift, and go to state 1

    program  go to state 2


State 1

    2 program: PROGRAM . ID @1 opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body '.'

    ID  shift, and go to state 3


State 2

    0 $accept: program . $end

    $end  shift, and go to state 4


State 3

    2 program: PROGRAM ID . @1 opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body '.'

    $default  reduce using rule 1 (@1)

    @1  go to state 5


State 4

    0 $accept: program $end .

    $default  accept


State 5

    2 program: PROGRAM ID @1 . opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body '.'

    TYPE  shift, and go to state 6

    $default  reduce using rule 4 (opt-type-sect)

    opt-type-sect  go to state 7


State 6

    3 opt-type-sect: TYPE . decl-list

    ID  shift, and go to state 8

    decl-list  go to state 9
    decl       go to state 10
    id-list    go to state 11


State 7

    2 program: PROGRAM ID @1 opt-type-sect . opt-var-sect opt-const-sect opt-module-list stat-body '.'

    VAR  shift, and go to state 12

    $default  reduce using rule 20 (opt-var-sect)

    opt-var-sect  go to state 13


State 8

    9 id-list: ID . @2 ',' id-list
   10        | ID .

    ':'       reduce using rule 10 (id-list)
    $default  reduce using rule 8 (@2)

    @2  go to state 14


State 9

    3 opt-type-sect: TYPE decl-list .

    $default  reduce using rule 3 (opt-type-sect)


State 10

    5 decl-list: decl . ';' decl-list
    6          | decl . ';'

    ';'  shift, and go to state 15


State 11

    7 decl: id-list . ':' domain

    ':'  shift, and go to state 16


State 12

   19 opt-var-sect: VAR . decl-list

    ID  shift, and go to state 8

    decl-list  go to state 17
    decl       go to state 10
    id-list    go to state 11


State 13

    2 program: PROGRAM ID @1 opt-type-sect opt-var-sect . opt-const-sect opt-module-list stat-body '.'

    CONST  shift, and go to state 18

    $default  reduce using rule 22 (opt-const-sect)

    opt-const-sect  go to state 19


State 14

    9 id-list: ID @2 . ',' id-list

    ','  shift, and go to state 20


State 15

    5 decl-list: decl ';' . decl-list
    6          | decl ';' .

    ID  shift, and go to state 8

    $default  reduce using rule 6 (decl-list)

    decl-list  go to state 21
    decl       go to state 10
    id-list    go to state 11


State 16

    7 decl: id-list ':' . domain

    INTEGER  shift, and go to state 22
    STRING   shift, and go to state 23
    BOOLEAN  shift, and go to state 24
    ID       shift, and go to state 25
    ARRAY    shift, and go to state 26

    domain         go to state 27
    atomic-domain  go to state 28
    array-domain   go to state 29


State 17

   19 opt-var-sect: VAR decl-list .

    $default  reduce using rule 19 (opt-var-sect)


State 18

   21 opt-const-sect: CONST . const-list-decl

    ID  shift, and go to state 8

    decl             go to state 30
    id-list          go to state 11
    const-list-decl  go to state 31
    const-decl       go to state 32


State 19

    2 program: PROGRAM ID @1 opt-type-sect opt-var-sect opt-const-sect . opt-module-list stat-body '.'

    PROC  shift, and go to state 33
    FUNC  shift, and go to state 34

    $default  reduce using rule 34 (opt-module-list)

    opt-module-list  go to state 35
    module-list      go to state 36
    module-decl      go to state 37
    procedure-decl   go to state 38
    function-decl    go to state 39


State 20

    9 id-list: ID @2 ',' . id-list

    ID  shift, and go to state 8

    id-list  go to state 40


State 21

    5 decl-list: decl ';' decl-list .

    $default  reduce using rule 5 (decl-list)


State 22

   14 atomic-domain: INTEGER .

    $default  reduce using rule 14 (atomic-domain)


State 23

   15 atomic-domain: STRING .

    $default  reduce using rule 15 (atomic-domain)


State 24

   16 atomic-domain: BOOLEAN .

    $default  reduce using rule 16 (atomic-domain)


State 25

   13 domain: ID .

    $default  reduce using rule 13 (domain)


State 26

   18 array-domain: ARRAY . '[' INTCONST @3 ']' OF domain

    '['  shift, and go to state 41


State 27

    7 decl: id-list ':' domain .

    $default  reduce using rule 7 (decl)


State 28

   11 domain: atomic-domain .

    $default  reduce using rule 11 (domain)


State 29

   12 domain: array-domain .

    $default  reduce using rule 12 (domain)


State 30

   25 const-decl: decl . ASSIGN const ';'

    ASSIGN  shift, and go to state 42


State 31

   21 opt-const-sect: CONST const-list-decl .

    $default  reduce using rule 21 (opt-const-sect)


State 32

   23 const-list-decl: const-decl . const-list-decl
   24                | const-decl .

    ID  shift, and go to state 8

    $default  reduce using rule 24 (const-list-decl)

    decl             go to state 30
    id-list          go to state 11
    const-list-decl  go to state 43
    const-decl       go to state 32


State 33

   40 procedure-decl: PROC . ID @4 '(' opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body ';'

    ID  shift, and go to state 44


State 34

   42 function-decl: FUNC . ID @5 '(' opt-formal-list ')' ':' domain opt-type-sect opt-const-sect opt-module-list expr-body ';'

    ID  shift, and go to state 45


State 35

    2 program: PROGRAM ID @1 opt-type-sect opt-var-sect opt-const-sect opt-module-list . stat-body '.'

    T_BEGIN  shift, and go to state 46

    stat-body  go to state 47


State 36

   33 opt-module-list: module-list .

    $default  reduce using rule 33 (opt-module-list)


State 37

   35 module-list: module-decl . module-list
   36            | module-decl .

    PROC  shift, and go to state 33
    FUNC  shift, and go to state 34

    $default  reduce using rule 36 (module-list)

    module-list     go to state 48
    module-decl     go to state 37
    procedure-decl  go to state 38
    function-decl   go to state 39


State 38

   37 module-decl: procedure-decl .

    $default  reduce using rule 37 (module-decl)


State 39

   38 module-decl: function-decl .

    $default  reduce using rule 38 (module-decl)


State 40

    9 id-list: ID @2 ',' id-list .

    $default  reduce using rule 9 (id-list)


State 41

   18 array-domain: ARRAY '[' . INTCONST @3 ']' OF domain

    INTCONST  shift, and go to state 49


State 42

   25 const-decl: decl ASSIGN . const ';'

    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    '['        shift, and go to state 53

    const        go to state 54
    array-const  go to state 55


State 43

   23 const-list-decl: const-decl const-list-decl .

    $default  reduce using rule 23 (const-list-decl)


State 44

   40 procedure-decl: PROC ID . @4 '(' opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body ';'

    $default  reduce using rule 39 (@4)

    @4  go to state 56


State 45

   42 function-decl: FUNC ID . @5 '(' opt-formal-list ')' ':' domain opt-type-sect opt-const-sect opt-module-list expr-body ';'

    $default  reduce using rule 41 (@5)

    @5  go to state 57


State 46

   53 stat-body: T_BEGIN . ID @6 stat-list END ID @7

    ID  shift, and go to state 58


State 47

    2 program: PROGRAM ID @1 opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body . '.'

    '.'  shift, and go to state 59


State 48

   35 module-list: module-decl module-list .

    $default  reduce using rule 35 (module-list)


State 49

   18 array-domain: ARRAY '[' INTCONST . @3 ']' OF domain

    $default  reduce using rule 17 (@3)

    @3  go to state 60


State 50

   26 const: INTCONST .

    $default  reduce using rule 26 (const)


State 51

   28 const: BOOLCONST .

    $default  reduce using rule 28 (const)


State 52

   27 const: STRCONST .

    $default  reduce using rule 27 (const)


State 53

   30 array-const: '[' . const-list ']'

    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    '['        shift, and go to state 53

    const        go to state 61
    array-const  go to state 55
    const-list   go to state 62


State 54

   25 const-decl: decl ASSIGN const . ';'

    ';'  shift, and go to state 63


State 55

   29 const: array-const .

    $default  reduce using rule 29 (const)


State 56

   40 procedure-decl: PROC ID @4 . '(' opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body ';'

    '('  shift, and go to state 64


State 57

   42 function-decl: FUNC ID @5 . '(' opt-formal-list ')' ':' domain opt-type-sect opt-const-sect opt-module-list expr-body ';'

    '('  shift, and go to state 65


State 58

   53 stat-body: T_BEGIN ID . @6 stat-list END ID @7

    $default  reduce using rule 51 (@6)

    @6  go to state 66


State 59

    2 program: PROGRAM ID @1 opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body '.' .

    $default  reduce using rule 2 (program)


State 60

   18 array-domain: ARRAY '[' INTCONST @3 . ']' OF domain

    ']'  shift, and go to state 67


State 61

   31 const-list: const . ',' const-list
   32           | const .

    ','  shift, and go to state 68

    $default  reduce using rule 32 (const-list)


State 62

   30 array-const: '[' const-list . ']'

    ']'  shift, and go to state 69


State 63

   25 const-decl: decl ASSIGN const ';' .

    $default  reduce using rule 25 (const-decl)


State 64

   40 procedure-decl: PROC ID @4 '(' . opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body ';'

    OUT    shift, and go to state 70
    INOUT  shift, and go to state 71

    ID        reduce using rule 48 (mode)
    $default  reduce using rule 44 (opt-formal-list)

    opt-formal-list  go to state 72
    formal-list      go to state 73
    formal-decl      go to state 74
    mode             go to state 75


State 65

   42 function-decl: FUNC ID @5 '(' . opt-formal-list ')' ':' domain opt-type-sect opt-const-sect opt-module-list expr-body ';'

    OUT    shift, and go to state 70
    INOUT  shift, and go to state 71

    ID        reduce using rule 48 (mode)
    $default  reduce using rule 44 (opt-formal-list)

    opt-formal-list  go to state 76
    formal-list      go to state 73
    formal-decl      go to state 74
    mode             go to state 75


State 66

   53 stat-body: T_BEGIN ID @6 . stat-list END ID @7

    BREAK   shift, and go to state 77
    EXIT    shift, and go to state 78
    IF      shift, and go to state 79
    WHILE   shift, and go to state 80
    REPEAT  shift, and go to state 81
    FOR     shift, and go to state 82
    INPUT   shift, and go to state 83
    OUTPUT  shift, and go to state 84
    ID      shift, and go to state 85

    stat-list       go to state 86
    stat            go to state 87
    input-stat      go to state 88
    output-stat     go to state 89
    for-stat        go to state 90
    while-stat      go to state 91
    repeat-stat     go to state 92
    if-stat         go to state 93
    assign-stat     go to state 94
    left-hand-side  go to state 95
    indexing        go to state 96
    module-call     go to state 97


State 67

   18 array-domain: ARRAY '[' INTCONST @3 ']' . OF domain

    OF  shift, and go to state 98


State 68

   31 const-list: const ',' . const-list

    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    '['        shift, and go to state 53

    const        go to state 61
    array-const  go to state 55
    const-list   go to state 99


State 69

   30 array-const: '[' const-list ']' .

    $default  reduce using rule 30 (array-const)


State 70

   49 mode: OUT .

    $default  reduce using rule 49 (mode)


State 71

   50 mode: INOUT .

    $default  reduce using rule 50 (mode)


State 72

   40 procedure-decl: PROC ID @4 '(' opt-formal-list . ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body ';'

    ')'  shift, and go to state 100


State 73

   43 opt-formal-list: formal-list .

    $default  reduce using rule 43 (opt-formal-list)


State 74

   45 formal-list: formal-decl . ',' formal-list
   46            | formal-decl .

    ','  shift, and go to state 101

    $default  reduce using rule 46 (formal-list)


State 75

   47 formal-decl: mode . decl

    ID  shift, and go to state 8

    decl     go to state 102
    id-list  go to state 11


State 76

   42 function-decl: FUNC ID @5 '(' opt-formal-list . ')' ':' domain opt-type-sect opt-const-sect opt-module-list expr-body ';'

    ')'  shift, and go to state 103


State 77

   67 stat: BREAK .

    $default  reduce using rule 67 (stat)


State 78

   68 stat: EXIT .

    $default  reduce using rule 68 (stat)


State 79

   75 if-stat: IF . expr THEN stat-list opt-elsif-stat-list opt-else-stat END

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 110
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 80

   73 while-stat: WHILE . expr DO stat-list END

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 118
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 81

   74 repeat-stat: REPEAT . stat-list UNTIL expr

    BREAK   shift, and go to state 77
    EXIT    shift, and go to state 78
    IF      shift, and go to state 79
    WHILE   shift, and go to state 80
    REPEAT  shift, and go to state 81
    FOR     shift, and go to state 82
    INPUT   shift, and go to state 83
    OUTPUT  shift, and go to state 84
    ID      shift, and go to state 85

    stat-list       go to state 119
    stat            go to state 87
    input-stat      go to state 88
    output-stat     go to state 89
    for-stat        go to state 90
    while-stat      go to state 91
    repeat-stat     go to state 92
    if-stat         go to state 93
    assign-stat     go to state 94
    left-hand-side  go to state 95
    indexing        go to state 96
    module-call     go to state 97


State 82

   72 for-stat: FOR . ID @10 ASSIGN expr TO expr DO stat-list END

    ID  shift, and go to state 120


State 83

   69 input-stat: INPUT . ID

    ID  shift, and go to state 121


State 84

   70 output-stat: OUTPUT . expr

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 122
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 85

   81 left-hand-side: ID .
  116 module-call: ID . @11 '(' opt-expr-list ')'

    '('       reduce using rule 115 (@11)
    $default  reduce using rule 81 (left-hand-side)

    @11  go to state 123


State 86

   53 stat-body: T_BEGIN ID @6 stat-list . END ID @7

    END  shift, and go to state 124


State 87

   57 stat-list: stat . ';' stat-list
   58          | stat . ';'

    ';'  shift, and go to state 125


State 88

   64 stat: input-stat .

    $default  reduce using rule 64 (stat)


State 89

   65 stat: output-stat .

    $default  reduce using rule 65 (stat)


State 90

   63 stat: for-stat .

    $default  reduce using rule 63 (stat)


State 91

   61 stat: while-stat .

    $default  reduce using rule 61 (stat)


State 92

   62 stat: repeat-stat .

    $default  reduce using rule 62 (stat)


State 93

   60 stat: if-stat .

    $default  reduce using rule 60 (stat)


State 94

   59 stat: assign-stat .

    $default  reduce using rule 59 (stat)


State 95

   80 assign-stat: left-hand-side . ASSIGN expr
   83 indexing: left-hand-side . '[' expr ']'

    ASSIGN  shift, and go to state 126
    '['     shift, and go to state 127


State 96

   82 left-hand-side: indexing .

    $default  reduce using rule 82 (left-hand-side)


State 97

   66 stat: module-call .

    $default  reduce using rule 66 (stat)


State 98

   18 array-domain: ARRAY '[' INTCONST @3 ']' OF . domain

    INTEGER  shift, and go to state 22
    STRING   shift, and go to state 23
    BOOLEAN  shift, and go to state 24
    ID       shift, and go to state 25
    ARRAY    shift, and go to state 26

    domain         go to state 128
    atomic-domain  go to state 28
    array-domain   go to state 29


State 99

   31 const-list: const ',' const-list .

    $default  reduce using rule 31 (const-list)


State 100

   40 procedure-decl: PROC ID @4 '(' opt-formal-list ')' . opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body ';'

    TYPE  shift, and go to state 6

    $default  reduce using rule 4 (opt-type-sect)

    opt-type-sect  go to state 129


State 101

   45 formal-list: formal-decl ',' . formal-list

    OUT    shift, and go to state 70
    INOUT  shift, and go to state 71

    $default  reduce using rule 48 (mode)

    formal-list  go to state 130
    formal-decl  go to state 74
    mode         go to state 75


State 102

   47 formal-decl: mode decl .

    $default  reduce using rule 47 (formal-decl)


State 103

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' . ':' domain opt-type-sect opt-const-sect opt-module-list expr-body ';'

    ':'  shift, and go to state 131


State 104

  110 unary-op: MINUS .

    $default  reduce using rule 110 (unary-op)


State 105

  112 cond-expr: IF . expr THEN expr opt-elsif-expr-list ELSE expr END

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 132
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 106

  111 unary-op: NOT .

    $default  reduce using rule 111 (unary-op)


State 107

  105 factor: '(' . expr ')'

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 133
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 108

  107 factor: const .

    $default  reduce using rule 107 (factor)


State 109

   83 indexing: left-hand-side . '[' expr ']'
  106 factor: left-hand-side .

    '['  shift, and go to state 127

    $default  reduce using rule 106 (factor)


State 110

   75 if-stat: IF expr . THEN stat-list opt-elsif-stat-list opt-else-stat END
   84 expr: expr . bool-op bool-term

    THEN  shift, and go to state 134
    AND   shift, and go to state 135
    OR    shift, and go to state 136

    bool-op  go to state 137


State 111

   85 expr: bool-term .

    $default  reduce using rule 85 (expr)


State 112

   88 bool-term: comp-term . comp-op comp-term
   89          | comp-term .
   96 comp-term: comp-term . add-op term

    EQUAL  shift, and go to state 138
    NE     shift, and go to state 139
    GT     shift, and go to state 140
    GE     shift, and go to state 141
    KT     shift, and go to state 142
    KE     shift, and go to state 143
    PLUS   shift, and go to state 144
    MINUS  shift, and go to state 145

    $default  reduce using rule 89 (bool-term)

    comp-op  go to state 146
    add-op   go to state 147


State 113

   97 comp-term: term .
  100 term: term . mul-op factor

    MUL  shift, and go to state 148
    DIV  shift, and go to state 149

    $default  reduce using rule 97 (comp-term)

    mul-op  go to state 150


State 114

  101 term: factor .

    $default  reduce using rule 101 (term)


State 115

  104 factor: unary-op . factor

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    factor          go to state 151
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 116

  108 factor: cond-expr .

    $default  reduce using rule 108 (factor)


State 117

  109 factor: module-call .

    $default  reduce using rule 109 (factor)


State 118

   73 while-stat: WHILE expr . DO stat-list END
   84 expr: expr . bool-op bool-term

    DO   shift, and go to state 152
    AND  shift, and go to state 135
    OR   shift, and go to state 136

    bool-op  go to state 137


State 119

   74 repeat-stat: REPEAT stat-list . UNTIL expr

    UNTIL  shift, and go to state 153


State 120

   72 for-stat: FOR ID . @10 ASSIGN expr TO expr DO stat-list END

    $default  reduce using rule 71 (@10)

    @10  go to state 154


State 121

   69 input-stat: INPUT ID .

    $default  reduce using rule 69 (input-stat)


State 122

   70 output-stat: OUTPUT expr .
   84 expr: expr . bool-op bool-term

    AND  shift, and go to state 135
    OR   shift, and go to state 136

    $default  reduce using rule 70 (output-stat)

    bool-op  go to state 137


State 123

  116 module-call: ID @11 . '(' opt-expr-list ')'

    '('  shift, and go to state 155


State 124

   53 stat-body: T_BEGIN ID @6 stat-list END . ID @7

    ID  shift, and go to state 156


State 125

   57 stat-list: stat ';' . stat-list
   58          | stat ';' .

    BREAK   shift, and go to state 77
    EXIT    shift, and go to state 78
    IF      shift, and go to state 79
    WHILE   shift, and go to state 80
    REPEAT  shift, and go to state 81
    FOR     shift, and go to state 82
    INPUT   shift, and go to state 83
    OUTPUT  shift, and go to state 84
    ID      shift, and go to state 85

    $default  reduce using rule 58 (stat-list)

    stat-list       go to state 157
    stat            go to state 87
    input-stat      go to state 88
    output-stat     go to state 89
    for-stat        go to state 90
    while-stat      go to state 91
    repeat-stat     go to state 92
    if-stat         go to state 93
    assign-stat     go to state 94
    left-hand-side  go to state 95
    indexing        go to state 96
    module-call     go to state 97


State 126

   80 assign-stat: left-hand-side ASSIGN . expr

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 158
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 127

   83 indexing: left-hand-side '[' . expr ']'

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 159
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 128

   18 array-domain: ARRAY '[' INTCONST @3 ']' OF domain .

    $default  reduce using rule 18 (array-domain)


State 129

   40 procedure-decl: PROC ID @4 '(' opt-formal-list ')' opt-type-sect . opt-var-sect opt-const-sect opt-module-list stat-body ';'

    VAR  shift, and go to state 12

    $default  reduce using rule 20 (opt-var-sect)

    opt-var-sect  go to state 160


State 130

   45 formal-list: formal-decl ',' formal-list .

    $default  reduce using rule 45 (formal-list)


State 131

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' ':' . domain opt-type-sect opt-const-sect opt-module-list expr-body ';'

    INTEGER  shift, and go to state 22
    STRING   shift, and go to state 23
    BOOLEAN  shift, and go to state 24
    ID       shift, and go to state 25
    ARRAY    shift, and go to state 26

    domain         go to state 161
    atomic-domain  go to state 28
    array-domain   go to state 29


State 132

   84 expr: expr . bool-op bool-term
  112 cond-expr: IF expr . THEN expr opt-elsif-expr-list ELSE expr END

    THEN  shift, and go to state 162
    AND   shift, and go to state 135
    OR    shift, and go to state 136

    bool-op  go to state 137


State 133

   84 expr: expr . bool-op bool-term
  105 factor: '(' expr . ')'

    AND  shift, and go to state 135
    OR   shift, and go to state 136
    ')'  shift, and go to state 163

    bool-op  go to state 137


State 134

   75 if-stat: IF expr THEN . stat-list opt-elsif-stat-list opt-else-stat END

    BREAK   shift, and go to state 77
    EXIT    shift, and go to state 78
    IF      shift, and go to state 79
    WHILE   shift, and go to state 80
    REPEAT  shift, and go to state 81
    FOR     shift, and go to state 82
    INPUT   shift, and go to state 83
    OUTPUT  shift, and go to state 84
    ID      shift, and go to state 85

    stat-list       go to state 164
    stat            go to state 87
    input-stat      go to state 88
    output-stat     go to state 89
    for-stat        go to state 90
    while-stat      go to state 91
    repeat-stat     go to state 92
    if-stat         go to state 93
    assign-stat     go to state 94
    left-hand-side  go to state 95
    indexing        go to state 96
    module-call     go to state 97


State 135

   86 bool-op: AND .

    $default  reduce using rule 86 (bool-op)


State 136

   87 bool-op: OR .

    $default  reduce using rule 87 (bool-op)


State 137

   84 expr: expr bool-op . bool-term

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    bool-term       go to state 165
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 138

   90 comp-op: EQUAL .

    $default  reduce using rule 90 (comp-op)


State 139

   91 comp-op: NE .

    $default  reduce using rule 91 (comp-op)


State 140

   92 comp-op: GT .

    $default  reduce using rule 92 (comp-op)


State 141

   93 comp-op: GE .

    $default  reduce using rule 93 (comp-op)


State 142

   94 comp-op: KT .

    $default  reduce using rule 94 (comp-op)


State 143

   95 comp-op: KE .

    $default  reduce using rule 95 (comp-op)


State 144

   98 add-op: PLUS .

    $default  reduce using rule 98 (add-op)


State 145

   99 add-op: MINUS .

    $default  reduce using rule 99 (add-op)


State 146

   88 bool-term: comp-term comp-op . comp-term

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    comp-term       go to state 166
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 147

   96 comp-term: comp-term add-op . term

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    term            go to state 167
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 148

  102 mul-op: MUL .

    $default  reduce using rule 102 (mul-op)


State 149

  103 mul-op: DIV .

    $default  reduce using rule 103 (mul-op)


State 150

  100 term: term mul-op . factor

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    factor          go to state 168
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 151

  104 factor: unary-op factor .

    $default  reduce using rule 104 (factor)


State 152

   73 while-stat: WHILE expr DO . stat-list END

    BREAK   shift, and go to state 77
    EXIT    shift, and go to state 78
    IF      shift, and go to state 79
    WHILE   shift, and go to state 80
    REPEAT  shift, and go to state 81
    FOR     shift, and go to state 82
    INPUT   shift, and go to state 83
    OUTPUT  shift, and go to state 84
    ID      shift, and go to state 85

    stat-list       go to state 169
    stat            go to state 87
    input-stat      go to state 88
    output-stat     go to state 89
    for-stat        go to state 90
    while-stat      go to state 91
    repeat-stat     go to state 92
    if-stat         go to state 93
    assign-stat     go to state 94
    left-hand-side  go to state 95
    indexing        go to state 96
    module-call     go to state 97


State 153

   74 repeat-stat: REPEAT stat-list UNTIL . expr

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 170
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 154

   72 for-stat: FOR ID @10 . ASSIGN expr TO expr DO stat-list END

    ASSIGN  shift, and go to state 171


State 155

  116 module-call: ID @11 '(' . opt-expr-list ')'

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    $default  reduce using rule 118 (opt-expr-list)

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 172
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117
    opt-expr-list   go to state 173
    expr-list       go to state 174


State 156

   53 stat-body: T_BEGIN ID @6 stat-list END ID . @7

    $default  reduce using rule 52 (@7)

    @7  go to state 175


State 157

   57 stat-list: stat ';' stat-list .

    $default  reduce using rule 57 (stat-list)


State 158

   80 assign-stat: left-hand-side ASSIGN expr .
   84 expr: expr . bool-op bool-term

    AND  shift, and go to state 135
    OR   shift, and go to state 136

    $default  reduce using rule 80 (assign-stat)

    bool-op  go to state 137


State 159

   83 indexing: left-hand-side '[' expr . ']'
   84 expr: expr . bool-op bool-term

    AND  shift, and go to state 135
    OR   shift, and go to state 136
    ']'  shift, and go to state 176

    bool-op  go to state 137


State 160

   40 procedure-decl: PROC ID @4 '(' opt-formal-list ')' opt-type-sect opt-var-sect . opt-const-sect opt-module-list stat-body ';'

    CONST  shift, and go to state 18

    $default  reduce using rule 22 (opt-const-sect)

    opt-const-sect  go to state 177


State 161

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' ':' domain . opt-type-sect opt-const-sect opt-module-list expr-body ';'

    TYPE  shift, and go to state 6

    $default  reduce using rule 4 (opt-type-sect)

    opt-type-sect  go to state 178


State 162

  112 cond-expr: IF expr THEN . expr opt-elsif-expr-list ELSE expr END

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 179
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 163

  105 factor: '(' expr ')' .

    $default  reduce using rule 105 (factor)


State 164

   75 if-stat: IF expr THEN stat-list . opt-elsif-stat-list opt-else-stat END

    ELSIF  shift, and go to state 180

    $default  reduce using rule 77 (opt-elsif-stat-list)

    opt-elsif-stat-list  go to state 181


State 165

   84 expr: expr bool-op bool-term .

    $default  reduce using rule 84 (expr)


State 166

   88 bool-term: comp-term comp-op comp-term .
   96 comp-term: comp-term . add-op term

    PLUS   shift, and go to state 144
    MINUS  shift, and go to state 145

    $default  reduce using rule 88 (bool-term)

    add-op  go to state 147


State 167

   96 comp-term: comp-term add-op term .
  100 term: term . mul-op factor

    MUL  shift, and go to state 148
    DIV  shift, and go to state 149

    $default  reduce using rule 96 (comp-term)

    mul-op  go to state 150


State 168

  100 term: term mul-op factor .

    $default  reduce using rule 100 (term)


State 169

   73 while-stat: WHILE expr DO stat-list . END

    END  shift, and go to state 182


State 170

   74 repeat-stat: REPEAT stat-list UNTIL expr .
   84 expr: expr . bool-op bool-term

    AND  shift, and go to state 135
    OR   shift, and go to state 136

    $default  reduce using rule 74 (repeat-stat)

    bool-op  go to state 137


State 171

   72 for-stat: FOR ID @10 ASSIGN . expr TO expr DO stat-list END

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 183
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 172

   84 expr: expr . bool-op bool-term
  119 expr-list: expr . ',' expr-list
  120          | expr .

    AND  shift, and go to state 135
    OR   shift, and go to state 136
    ','  shift, and go to state 184

    $default  reduce using rule 120 (expr-list)

    bool-op  go to state 137


State 173

  116 module-call: ID @11 '(' opt-expr-list . ')'

    ')'  shift, and go to state 185


State 174

  117 opt-expr-list: expr-list .

    $default  reduce using rule 117 (opt-expr-list)


State 175

   53 stat-body: T_BEGIN ID @6 stat-list END ID @7 .

    $default  reduce using rule 53 (stat-body)


State 176

   83 indexing: left-hand-side '[' expr ']' .

    $default  reduce using rule 83 (indexing)


State 177

   40 procedure-decl: PROC ID @4 '(' opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect . opt-module-list stat-body ';'

    PROC  shift, and go to state 33
    FUNC  shift, and go to state 34

    $default  reduce using rule 34 (opt-module-list)

    opt-module-list  go to state 186
    module-list      go to state 36
    module-decl      go to state 37
    procedure-decl   go to state 38
    function-decl    go to state 39


State 178

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' ':' domain opt-type-sect . opt-const-sect opt-module-list expr-body ';'

    CONST  shift, and go to state 18

    $default  reduce using rule 22 (opt-const-sect)

    opt-const-sect  go to state 187


State 179

   84 expr: expr . bool-op bool-term
  112 cond-expr: IF expr THEN expr . opt-elsif-expr-list ELSE expr END

    ELSIF  shift, and go to state 188
    AND    shift, and go to state 135
    OR     shift, and go to state 136

    $default  reduce using rule 114 (opt-elsif-expr-list)

    bool-op              go to state 137
    opt-elsif-expr-list  go to state 189


State 180

   76 opt-elsif-stat-list: ELSIF . expr THEN stat-list opt-elsif-stat-list

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 190
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 181

   75 if-stat: IF expr THEN stat-list opt-elsif-stat-list . opt-else-stat END

    ELSE  shift, and go to state 191

    $default  reduce using rule 79 (opt-else-stat)

    opt-else-stat  go to state 192


State 182

   73 while-stat: WHILE expr DO stat-list END .

    $default  reduce using rule 73 (while-stat)


State 183

   72 for-stat: FOR ID @10 ASSIGN expr . TO expr DO stat-list END
   84 expr: expr . bool-op bool-term

    TO   shift, and go to state 193
    AND  shift, and go to state 135
    OR   shift, and go to state 136

    bool-op  go to state 137


State 184

  119 expr-list: expr ',' . expr-list

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 172
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117
    expr-list       go to state 194


State 185

  116 module-call: ID @11 '(' opt-expr-list ')' .

    $default  reduce using rule 116 (module-call)


State 186

   40 procedure-decl: PROC ID @4 '(' opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list . stat-body ';'

    T_BEGIN  shift, and go to state 46

    stat-body  go to state 195


State 187

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' ':' domain opt-type-sect opt-const-sect . opt-module-list expr-body ';'

    PROC  shift, and go to state 33
    FUNC  shift, and go to state 34

    $default  reduce using rule 34 (opt-module-list)

    opt-module-list  go to state 196
    module-list      go to state 36
    module-decl      go to state 37
    procedure-decl   go to state 38
    function-decl    go to state 39


State 188

  113 opt-elsif-expr-list: ELSIF . expr THEN expr opt-elsif-expr-list

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 197
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 189

  112 cond-expr: IF expr THEN expr opt-elsif-expr-list . ELSE expr END

    ELSE  shift, and go to state 198


State 190

   76 opt-elsif-stat-list: ELSIF expr . THEN stat-list opt-elsif-stat-list
   84 expr: expr . bool-op bool-term

    THEN  shift, and go to state 199
    AND   shift, and go to state 135
    OR    shift, and go to state 136

    bool-op  go to state 137


State 191

   78 opt-else-stat: ELSE . stat-list

    BREAK   shift, and go to state 77
    EXIT    shift, and go to state 78
    IF      shift, and go to state 79
    WHILE   shift, and go to state 80
    REPEAT  shift, and go to state 81
    FOR     shift, and go to state 82
    INPUT   shift, and go to state 83
    OUTPUT  shift, and go to state 84
    ID      shift, and go to state 85

    stat-list       go to state 200
    stat            go to state 87
    input-stat      go to state 88
    output-stat     go to state 89
    for-stat        go to state 90
    while-stat      go to state 91
    repeat-stat     go to state 92
    if-stat         go to state 93
    assign-stat     go to state 94
    left-hand-side  go to state 95
    indexing        go to state 96
    module-call     go to state 97


State 192

   75 if-stat: IF expr THEN stat-list opt-elsif-stat-list opt-else-stat . END

    END  shift, and go to state 201


State 193

   72 for-stat: FOR ID @10 ASSIGN expr TO . expr DO stat-list END

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 202
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 194

  119 expr-list: expr ',' expr-list .

    $default  reduce using rule 119 (expr-list)


State 195

   40 procedure-decl: PROC ID @4 '(' opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body . ';'

    ';'  shift, and go to state 203


State 196

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' ':' domain opt-type-sect opt-const-sect opt-module-list . expr-body ';'

    T_BEGIN  shift, and go to state 204

    expr-body  go to state 205


State 197

   84 expr: expr . bool-op bool-term
  113 opt-elsif-expr-list: ELSIF expr . THEN expr opt-elsif-expr-list

    THEN  shift, and go to state 206
    AND   shift, and go to state 135
    OR    shift, and go to state 136

    bool-op  go to state 137


State 198

  112 cond-expr: IF expr THEN expr opt-elsif-expr-list ELSE . expr END

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 207
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 199

   76 opt-elsif-stat-list: ELSIF expr THEN . stat-list opt-elsif-stat-list

    BREAK   shift, and go to state 77
    EXIT    shift, and go to state 78
    IF      shift, and go to state 79
    WHILE   shift, and go to state 80
    REPEAT  shift, and go to state 81
    FOR     shift, and go to state 82
    INPUT   shift, and go to state 83
    OUTPUT  shift, and go to state 84
    ID      shift, and go to state 85

    stat-list       go to state 208
    stat            go to state 87
    input-stat      go to state 88
    output-stat     go to state 89
    for-stat        go to state 90
    while-stat      go to state 91
    repeat-stat     go to state 92
    if-stat         go to state 93
    assign-stat     go to state 94
    left-hand-side  go to state 95
    indexing        go to state 96
    module-call     go to state 97


State 200

   78 opt-else-stat: ELSE stat-list .

    $default  reduce using rule 78 (opt-else-stat)


State 201

   75 if-stat: IF expr THEN stat-list opt-elsif-stat-list opt-else-stat END .

    $default  reduce using rule 75 (if-stat)


State 202

   72 for-stat: FOR ID @10 ASSIGN expr TO expr . DO stat-list END
   84 expr: expr . bool-op bool-term

    DO   shift, and go to state 209
    AND  shift, and go to state 135
    OR   shift, and go to state 136

    bool-op  go to state 137


State 203

   40 procedure-decl: PROC ID @4 '(' opt-formal-list ')' opt-type-sect opt-var-sect opt-const-sect opt-module-list stat-body ';' .

    $default  reduce using rule 40 (procedure-decl)


State 204

   56 expr-body: T_BEGIN . ID @8 expr END ID @9

    ID  shift, and go to state 210


State 205

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' ':' domain opt-type-sect opt-const-sect opt-module-list expr-body . ';'

    ';'  shift, and go to state 211


State 206

  113 opt-elsif-expr-list: ELSIF expr THEN . expr opt-elsif-expr-list

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 212
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 207

   84 expr: expr . bool-op bool-term
  112 cond-expr: IF expr THEN expr opt-elsif-expr-list ELSE expr . END

    END  shift, and go to state 213
    AND  shift, and go to state 135
    OR   shift, and go to state 136

    bool-op  go to state 137


State 208

   76 opt-elsif-stat-list: ELSIF expr THEN stat-list . opt-elsif-stat-list

    ELSIF  shift, and go to state 180

    $default  reduce using rule 77 (opt-elsif-stat-list)

    opt-elsif-stat-list  go to state 214


State 209

   72 for-stat: FOR ID @10 ASSIGN expr TO expr DO . stat-list END

    BREAK   shift, and go to state 77
    EXIT    shift, and go to state 78
    IF      shift, and go to state 79
    WHILE   shift, and go to state 80
    REPEAT  shift, and go to state 81
    FOR     shift, and go to state 82
    INPUT   shift, and go to state 83
    OUTPUT  shift, and go to state 84
    ID      shift, and go to state 85

    stat-list       go to state 215
    stat            go to state 87
    input-stat      go to state 88
    output-stat     go to state 89
    for-stat        go to state 90
    while-stat      go to state 91
    repeat-stat     go to state 92
    if-stat         go to state 93
    assign-stat     go to state 94
    left-hand-side  go to state 95
    indexing        go to state 96
    module-call     go to state 97


State 210

   56 expr-body: T_BEGIN ID . @8 expr END ID @9

    $default  reduce using rule 54 (@8)

    @8  go to state 216


State 211

   42 function-decl: FUNC ID @5 '(' opt-formal-list ')' ':' domain opt-type-sect opt-const-sect opt-module-list expr-body ';' .

    $default  reduce using rule 42 (function-decl)


State 212

   84 expr: expr . bool-op bool-term
  113 opt-elsif-expr-list: ELSIF expr THEN expr . opt-elsif-expr-list

    ELSIF  shift, and go to state 188
    AND    shift, and go to state 135
    OR     shift, and go to state 136

    $default  reduce using rule 114 (opt-elsif-expr-list)

    bool-op              go to state 137
    opt-elsif-expr-list  go to state 217


State 213

  112 cond-expr: IF expr THEN expr opt-elsif-expr-list ELSE expr END .

    $default  reduce using rule 112 (cond-expr)


State 214

   76 opt-elsif-stat-list: ELSIF expr THEN stat-list opt-elsif-stat-list .

    $default  reduce using rule 76 (opt-elsif-stat-list)


State 215

   72 for-stat: FOR ID @10 ASSIGN expr TO expr DO stat-list . END

    END  shift, and go to state 218


State 216

   56 expr-body: T_BEGIN ID @8 . expr END ID @9

    MINUS      shift, and go to state 104
    IF         shift, and go to state 105
    NOT        shift, and go to state 106
    INTCONST   shift, and go to state 50
    BOOLCONST  shift, and go to state 51
    STRCONST   shift, and go to state 52
    ID         shift, and go to state 85
    '['        shift, and go to state 53
    '('        shift, and go to state 107

    const           go to state 108
    array-const     go to state 55
    left-hand-side  go to state 109
    indexing        go to state 96
    expr            go to state 219
    bool-term       go to state 111
    comp-term       go to state 112
    term            go to state 113
    factor          go to state 114
    unary-op        go to state 115
    cond-expr       go to state 116
    module-call     go to state 117


State 217

  113 opt-elsif-expr-list: ELSIF expr THEN expr opt-elsif-expr-list .

    $default  reduce using rule 113 (opt-elsif-expr-list)


State 218

   72 for-stat: FOR ID @10 ASSIGN expr TO expr DO stat-list END .

    $default  reduce using rule 72 (for-stat)


State 219

   56 expr-body: T_BEGIN ID @8 expr . END ID @9
   84 expr: expr . bool-op bool-term

    END  shift, and go to state 220
    AND  shift, and go to state 135
    OR   shift, and go to state 136

    bool-op  go to state 137


State 220

   56 expr-body: T_BEGIN ID @8 expr END . ID @9

    ID  shift, and go to state 221


State 221

   56 expr-body: T_BEGIN ID @8 expr END ID . @9

    $default  reduce using rule 55 (@9)

    @9  go to state 222


State 222

   56 expr-body: T_BEGIN ID @8 expr END ID @9 .

    $default  reduce using rule 56 (expr-body)
